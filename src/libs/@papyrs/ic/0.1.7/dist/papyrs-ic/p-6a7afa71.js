import{E as t,e,h as i}from"./p-46541408.js";import{S as n,g as s,A as o}from"./p-30f115e3.js";import{E as a,D as r,i as c,b as l,d as u,e as d}from"./p-f7cd2931.js";import{c as h}from"./p-82ae0ef6.js";var w=t=>{let e=new CustomEvent("ddgLog",{detail:t,bubbles:!0});document.dispatchEvent(e)};class f extends Error{constructor(t){super(t),this.message=t,Object.setPrototypeOf(this,f.prototype)}}function v(t){if(t)return t;if("undefined"!=typeof crypto&&crypto.subtle)return crypto.subtle;throw new f("Global crypto was not available and none was provided. Please inlcude a SubtleCrypto implementation. See https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto")}class y extends n{constructor(t,e,i){super(),this._keyPair=t,this._derKey=e,this._subtleCrypto=i}static async generate(t){const{extractable:e=!1,keyUsages:i=["sign","verify"],subtleCrypto:n}=null!=t?t:{},s=v(n),o=await s.generateKey({name:"ECDSA",namedCurve:"P-256"},e,i);return new this(o,await s.exportKey("spki",o.publicKey),s)}static async fromKeyPair(t,e){const i=v(e),n=await i.exportKey("spki",t.publicKey);return new y(t,n,i)}getKeyPair(){return this._keyPair}getPublicKey(){const t=this._derKey,e=Object.create(this._keyPair.publicKey);return e.toDer=function(){return t},e}async sign(t){return await this._subtleCrypto.sign({name:"ECDSA",hash:{name:"SHA-256"}},this._keyPair.privateKey,t)}}const g=["mousedown","mousemove","keydown","touchstart","wheel"];class m{constructor(t={}){var e;this.callbacks=[],this.idleTimeout=6e5,this.timeoutID=void 0;const{onIdle:i,idleTimeout:n=6e5}=t||{};this.callbacks=i?[i]:[],this.idleTimeout=n;const s=this._resetTimer.bind(this);if(window.addEventListener("load",s,!0),g.forEach((function(t){document.addEventListener(t,s,!0)})),null==t?void 0:t.captureScroll){const i=((t,e)=>{let i;return(...n)=>{const s=this;clearTimeout(i),i=window.setTimeout((function(){i=void 0,t.apply(s,n)}),e)}})(s,null!==(e=null==t?void 0:t.scrollDebounce)&&void 0!==e?e:100);window.addEventListener("scroll",i,!0)}s()}static create(t={}){return new this(t)}registerCallback(t){this.callbacks.push(t)}exit(){clearTimeout(this.timeoutID),window.removeEventListener("load",this._resetTimer,!0);const t=this._resetTimer.bind(this);g.forEach((function(e){document.removeEventListener(e,t,!0)})),this.callbacks.forEach((t=>t()))}_resetTimer(){const t=this.exit.bind(this);window.clearTimeout(this.timeoutID),this.timeoutID=window.setTimeout(t,this.idleTimeout)}}let p,b;const I=new WeakMap,D=new WeakMap,S=new WeakMap,E=new WeakMap,k=new WeakMap;let B={get(t,e,i){if(t instanceof IDBTransaction){if("done"===e)return D.get(t);if("objectStoreNames"===e)return t.objectStoreNames||S.get(t);if("store"===e)return i.objectStoreNames[1]?void 0:i.objectStore(i.objectStoreNames[0])}return j(t[e])},set:(t,e,i)=>(t[e]=i,!0),has:(t,e)=>t instanceof IDBTransaction&&("done"===e||"store"===e)||e in t};function C(t){return"function"==typeof t?(e=t)!==IDBDatabase.prototype.transaction||"objectStoreNames"in IDBTransaction.prototype?(b||(b=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])).includes(e)?function(...t){return e.apply(P(this),t),j(I.get(this))}:function(...t){return j(e.apply(P(this),t))}:function(t,...i){const n=e.call(P(this),t,...i);return S.set(n,t.sort?t.sort():[t]),j(n)}:(t instanceof IDBTransaction&&function(t){if(D.has(t))return;const e=new Promise(((e,i)=>{const n=()=>{t.removeEventListener("complete",s),t.removeEventListener("error",o),t.removeEventListener("abort",o)},s=()=>{e(),n()},o=()=>{i(t.error||new DOMException("AbortError","AbortError")),n()};t.addEventListener("complete",s),t.addEventListener("error",o),t.addEventListener("abort",o)}));D.set(t,e)}(t),i=t,(p||(p=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])).some((t=>i instanceof t))?new Proxy(t,B):t);var e,i}function j(t){if(t instanceof IDBRequest)return function(t){const e=new Promise(((e,i)=>{const n=()=>{t.removeEventListener("success",s),t.removeEventListener("error",o)},s=()=>{e(j(t.result)),n()},o=()=>{i(t.error),n()};t.addEventListener("success",s),t.addEventListener("error",o)}));return e.then((e=>{e instanceof IDBCursor&&I.set(e,t)})).catch((()=>{})),k.set(e,t),e}(t);if(E.has(t))return E.get(t);const e=C(t);return e!==t&&(E.set(t,e),k.set(e,t)),e}const P=t=>k.get(t),T=["get","getKey","getAll","getAllKeys","count"],A=["put","add","delete","clear"],x=new Map;function O(t,e){if(!(t instanceof IDBDatabase)||e in t||"string"!=typeof e)return;if(x.get(e))return x.get(e);const i=e.replace(/FromIndex$/,""),n=e!==i,s=A.includes(i);if(!(i in(n?IDBIndex:IDBObjectStore).prototype)||!s&&!T.includes(i))return;const o=async function(t,...e){const o=this.transaction(t,s?"readwrite":"readonly");let a=o.store;return n&&(a=a.index(e.shift())),(await Promise.all([a[i](...e),s&&o.done]))[0]};return x.set(e,o),o}var M;M=B,B={...M,get:(t,e,i)=>O(t,e)||M.get(t,e,i),has:(t,e)=>!!O(t,e)||M.has(t,e)};const W="auth-client-db",z="ic-keyval";class K{constructor(t,e){this._db=t,this._storeName=e}static async create(t){const{dbName:e=W,storeName:i=z,version:n=1}=null!=t?t:{},s=await(async(t=W,e=z,i)=>(N&&(null===localStorage||void 0===localStorage?void 0:localStorage.getItem(_))&&(localStorage.removeItem(_),localStorage.removeItem(U)),await function(t,e,{blocked:i,upgrade:n,blocking:s,terminated:o}={}){const a=indexedDB.open(t,e),r=j(a);return n&&a.addEventListener("upgradeneeded",(t=>{n(j(a.result),t.oldVersion,t.newVersion,j(a.transaction),t)})),i&&a.addEventListener("blocked",(t=>i(t.oldVersion,t.newVersion,t))),r.then((t=>{o&&t.addEventListener("close",(()=>o())),s&&t.addEventListener("versionchange",(t=>s(t.oldVersion,t.newVersion,t)))})).catch((()=>{})),r}(t,i,{upgrade:t=>{t.objectStoreNames.contains(e)&&t.clear(e),t.createObjectStore(e)}})))(e,i,n);return new K(s,i)}async set(t,e){return await async function(t,e,i,n){return await t.put(e,n,i)}(this._db,this._storeName,t,e)}async get(t){var e;return null!==(e=await async function(t,e,i){return await t.get(e,i)}(this._db,this._storeName,t))&&void 0!==e?e:null}async remove(t){return await async function(t,e,i){return await t.delete(e,i)}(this._db,this._storeName,t)}}const U="identity",_="delegation",N="undefined"!=typeof window;class L{constructor(t="ic-",e){this.prefix=t,this._localStorage=e}get(t){return Promise.resolve(this._getLocalStorage().getItem(this.prefix+t))}set(t,e){return this._getLocalStorage().setItem(this.prefix+t,e),Promise.resolve()}remove(t){return this._getLocalStorage().removeItem(this.prefix+t),Promise.resolve()}_getLocalStorage(){if(this._localStorage)return this._localStorage;const t="undefined"==typeof window?void 0===s?"undefined"==typeof self?void 0:self.localStorage:s.localStorage:window.localStorage;if(!t)throw new Error("Could not find local storage.");return t}}class ${get _db(){return new Promise((t=>{this.initializedDb?t(this.initializedDb):K.create({version:1}).then((e=>{this.initializedDb=e,t(e)}))}))}async get(t){const e=await this._db;return await e.get(t)}async set(t,e){const i=await this._db;await i.set(t,e)}async remove(t){const e=await this._db;await e.remove(t)}}async function R(t){await t.remove(U),await t.remove(_),await t.remove("iv")}const F=(t,e)=>{const i=globalThis[e];return null!=i&&t instanceof i},G=t=>{if(null!=t){if(F(t,"ArrayBuffer")||F(t,"MessagePort")||F(t,"ImageBitmap")||F(t,"OffscreenCanvas"))return[t];if("object"==typeof t)return t.constructor===Object&&(t=Object.values(t)),Array.isArray(t)?t.flatMap(G):G(t.buffer)}return[]};let H=0,J=0;const q=new Map,Y=new Map,Q=(t,e,i)=>{const n=new Worker(t,{name:e});return n.addEventListener("message",(({data:t})=>{if(t){const e=t[0],n=t[1],s=t[2];if(e===i){const e=t[3],[i,o,a]=q.get(n);if(q.delete(n),e){const t=e.isError?Object.assign(new Error(e.value.message),e.value):e.value;h(t),o(t)}else a&&a.forEach((t=>Y.delete(t))),i(s)}else if(e===i+".cb")try{Y.get(n)(...s)}catch(t){h(t)}}})),n},V=(t,e,i)=>(...n)=>new Promise(((s,o)=>{let a=H++,r=0,c=n.length,l=[s,o];for(q.set(a,l);r<c;r++)if("function"==typeof n[r]){const t=J++;Y.set(t,n[r]),n[r]=[e+".cb",t],(l[2]=l[2]||[]).push(t)}const u=t=>t.postMessage([e,a,i,n],G(n));t.then?t.then(u):u(t)})),X=import("./p-c96057bd.js").then((t=>t.worker)),Z=V(X,"stencil.idle.ic.worker","startIdleTime"),tt=V(X,"stencil.idle.ic.worker","stopIdleTimer"),et=V(import("./p-9ddac112.js").then((t=>t.worker)),"stencil.user.ic.worker","initUserWorker");let it;const nt=()=>class{constructor(t,e,i,n,s,o,a,r){var c;this._identity=t,this._key=e,this._chain=i,this._storage=n,this.idleManager=s,this._createOptions=o,this._idpWindow=a,this._eventHandler=r;const l=this.logout.bind(this),u=null==o?void 0:o.idleOptions;(null==u?void 0:u.onIdle)||(null==u?void 0:u.disableDefaultIdleCallback)||null===(c=this.idleManager)||void 0===c||c.registerCallback((()=>{l(),location.reload()}))}static async create(t={}){var e,i,n;const s=null!==(e=t.storage)&&void 0!==e?e:new $,u=null!==(i=t.keyType)&&void 0!==i?i:"ECDSA";let d=null;if(t.identity)d=t.identity;else{let t=await s.get(U);if(!t&&N)try{const e=new L,i=await e.get(_),n=await e.get(U);i&&n&&"ECDSA"===u&&(console.log("Discovered an identity stored in localstorage. Migrating to IndexedDB"),await s.set(_,i),await s.set(U,n),t=i,await e.remove(_),await e.remove(U))}catch(t){console.error("error while attempting to recover localstorage: "+t)}if(t)try{"object"==typeof t?d="Ed25519"===u&&"string"==typeof t?await a.fromJSON(t):await y.fromKeyPair(t):"string"==typeof t&&(d=a.fromJSON(t))}catch(t){}}let h,w=new o,f=null;if(d)try{const e=await s.get(_);if("object"==typeof e&&null!==e)throw new Error("Delegation chain is incorrectly stored. A delegation chain should be stored as a string.");t.identity?w=t.identity:e&&(f=r.fromJSON(e),c(f)?w=l.fromDelegation(d,f):(await R(s),d=null))}catch(t){console.error(t),await R(s),d=null}return(null===(n=t.idleOptions)||void 0===n?void 0:n.disableIdle)?h=void 0:(f||t.identity)&&(h=m.create(t.idleOptions)),d||("Ed25519"===u?(d=await a.generate(),await s.set(U,JSON.stringify(d.toJSON()))):(t.storage&&"ECDSA"===u&&console.warn("You are using a custom storage provider that may not support CryptoKey storage. If you are using a custom storage provider that does not support CryptoKey storage, you should use 'Ed25519' as the key type, as it can serialize to a string"),d=await y.generate(),await s.set(U,d.getKeyPair()))),new this(w,d,f,s,h,t)}_handleSuccess(t,e){var i,n,s;const o=t.delegations.map((t=>({delegation:new u(t.delegation.pubkey,t.delegation.expiration,t.delegation.targets),signature:t.signature.buffer}))),a=r.fromDelegations(o,t.userPublicKey.buffer),c=this._key;if(c){if(this._chain=a,this._identity=l.fromDelegation(c,this._chain),null===(i=this._idpWindow)||void 0===i||i.close(),!this.idleManager){const t=null===(n=this._createOptions)||void 0===n?void 0:n.idleOptions;this.idleManager=m.create(t),(null==t?void 0:t.onIdle)||(null==t?void 0:t.disableDefaultIdleCallback)||null===(s=this.idleManager)||void 0===s||s.registerCallback((()=>{this.logout(),location.reload()}))}null==e||e(),this._removeEventListener(),delete this._idpWindow}}getIdentity(){return this._identity}async isAuthenticated(){return!this.getIdentity().getPrincipal().isAnonymous()&&null!==this._chain}async login(t){var e,i,n,s;const o=BigInt(8)*BigInt(36e11),a=new URL((null===(e=null==t?void 0:t.identityProvider)||void 0===e?void 0:e.toString())||"https://identity.ic0.app");a.hash="#authorize",null===(i=this._idpWindow)||void 0===i||i.close(),this._removeEventListener(),this._eventHandler=this._getEventHandler(a,Object.assign({maxTimeToLive:null!==(n=null==t?void 0:t.maxTimeToLive)&&void 0!==n?n:o},t)),window.addEventListener("message",this._eventHandler),this._idpWindow=null!==(s=window.open(a.toString(),"idpWindow",null==t?void 0:t.windowOpenerFeatures))&&void 0!==s?s:void 0;const r=()=>{this._idpWindow&&(this._idpWindow.closed?this._handleFailure("UserInterrupt",null==t?void 0:t.onError):setTimeout(r,500))};r()}_getEventHandler(t,e){return async i=>{var n,s,o;if(i.origin!==t.origin)return void console.warn(`WARNING: expected origin '${t.origin}', got '${i.origin}' (ignoring)`);const a=i.data;switch(a.kind){case"authorize-ready":{const i={kind:"authorize-client",sessionPublicKey:new Uint8Array(null===(n=this._key)||void 0===n?void 0:n.getPublicKey().toDer()),maxTimeToLive:null==e?void 0:e.maxTimeToLive,derivationOrigin:null===(s=null==e?void 0:e.derivationOrigin)||void 0===s?void 0:s.toString()};null===(o=this._idpWindow)||void 0===o||o.postMessage(i,t.origin);break}case"authorize-client-success":try{this._handleSuccess(a,null==e?void 0:e.onSuccess),this._chain&&await this._storage.set(_,JSON.stringify(this._chain.toJSON()))}catch(t){this._handleFailure(t.message,null==e?void 0:e.onError)}break;case"authorize-client-failure":this._handleFailure(a.text,null==e?void 0:e.onError)}}}_handleFailure(t,e){var i;null===(i=this._idpWindow)||void 0===i||i.close(),null==e||e(t),this._removeEventListener(),delete this._idpWindow}_removeEventListener(){this._eventHandler&&window.removeEventListener("message",this._eventHandler),this._eventHandler=void 0}async logout(t={}){if(await R(this._storage),this._identity=new o,this._chain=null,t.returnTo)try{window.history.pushState({},"",t.returnTo)}catch(e){window.location.href=t.returnTo}}}.create({idleOptions:{disableIdle:!0,disableDefaultIdleCallback:!0}}),st=async({config:e,success:i})=>{if(t.getInstance().set(e),it=await nt(),!await(null==it?void 0:it.isAuthenticated()))return;await ot({success:i});const n=async t=>await at({user:t,success:i});try{await et({env:t.getInstance().get()},n,w)}catch(t){const e=new CustomEvent("ddgInitUserError",{detail:t,bubbles:!0});return void document.dispatchEvent(e)}Z((()=>{const t=new CustomEvent("ddgSignOut",{bubbles:!0});document.dispatchEvent(t)})).then((()=>{}))},ot=async({success:t})=>{await t({authUser:{state:"initialization"},user:void 0})},at=async({user:t,success:e})=>{const{id:i,data:n}=t,{name:s,email:o,photo_url:a}=n,r={uid:i,state:"authenticated",name:s,email:o,photo_url:a};await e({authUser:r,user:t})},rt=async()=>{await tt(),await(null==it?void 0:it.logout()),it=void 0,await d("/user")},ct=async({onSuccess:i,onError:n})=>{it=it||await nt(),await it.login(Object.assign({onSuccess:i,onError:n,maxTimeToLive:e},t.getInstance().localIdentity()&&{identityProvider:`http://${t.getInstance().get().localIdentityCanisterId}.localhost:8000?#authorize`}))},lt=async()=>{const t=ut();if(!t)throw new Error("Invalid identity.");const e=await i({identity:t});await Promise.all([e.delData(),e.delStorage()])},ut=()=>null==it?void 0:it.getIdentity(),dt=()=>null==it?void 0:it.isAuthenticated();export{U as K,_ as a,st as b,V as c,ct as d,lt as e,Q as f,ut as g,dt as i,rt as s,w as t}